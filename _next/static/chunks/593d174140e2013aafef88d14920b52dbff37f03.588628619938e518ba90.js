(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[4],{"/0+H":function(e,n,t){"use strict";n.__esModule=!0,n.isInAmpMode=s,n.useAmp=function(){return s(a.default.useContext(o.AmpStateContext))};var r,a=(r=t("q1tI"))&&r.__esModule?r:{default:r},o=t("lwAK");function s(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.ampFirst,t=void 0!==n&&n,r=e.hybrid,a=void 0!==r&&r,o=e.hasQuery,s=void 0!==o&&o;return t||a&&s}},"8Kt/":function(e,n,t){"use strict";t("lSNA");n.__esModule=!0,n.defaultHead=p,n.default=void 0;var r,a=function(e){if(e&&e.__esModule)return e;if(null===e||"object"!==typeof e&&"function"!==typeof e)return{default:e};var n=c();if(n&&n.has(e))return n.get(e);var t={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if(Object.prototype.hasOwnProperty.call(e,a)){var o=r?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(t,a,o):t[a]=e[a]}t.default=e,n&&n.set(e,t);return t}(t("q1tI")),o=(r=t("Xuae"))&&r.__esModule?r:{default:r},s=t("lwAK"),i=t("FYa8"),l=t("/0+H");function c(){if("function"!==typeof WeakMap)return null;var e=new WeakMap;return c=function(){return e},e}function p(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=[a.default.createElement("meta",{charSet:"utf-8"})];return e||n.push(a.default.createElement("meta",{name:"viewport",content:"width=device-width"})),n}function u(e,n){return"string"===typeof n||"number"===typeof n?e:n.type===a.default.Fragment?e.concat(a.default.Children.toArray(n.props.children).reduce((function(e,n){return"string"===typeof n||"number"===typeof n?e:e.concat(n)}),[])):e.concat(n)}var h=["name","httpEquiv","charSet","itemProp"];function d(e,n){return e.reduce((function(e,n){var t=a.default.Children.toArray(n.props.children);return e.concat(t)}),[]).reduce(u,[]).reverse().concat(p(n.inAmpMode)).filter(function(){var e=new Set,n=new Set,t=new Set,r={};return function(a){var o=!0;if(a.key&&"number"!==typeof a.key&&a.key.indexOf("$")>0){var s=a.key.slice(a.key.indexOf("$")+1);e.has(s)?o=!1:e.add(s)}switch(a.type){case"title":case"base":n.has(a.type)?o=!1:n.add(a.type);break;case"meta":for(var i=0,l=h.length;i<l;i++){var c=h[i];if(a.props.hasOwnProperty(c))if("charSet"===c)t.has(c)?o=!1:t.add(c);else{var p=a.props[c],u=r[c]||new Set;u.has(p)?o=!1:(u.add(p),r[c]=u)}}}return o}}()).reverse().map((function(e,n){var t=e.key||n;return a.default.cloneElement(e,{key:t})}))}function f(e){var n=e.children,t=(0,a.useContext)(s.AmpStateContext),r=(0,a.useContext)(i.HeadManagerContext);return a.default.createElement(o.default,{reduceComponentsToState:d,headManager:r,inAmpMode:(0,l.isInAmpMode)(t)},n)}f.rewind=function(){};var m=f;n.default=m},Bnag:function(e,n){e.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},EbDI:function(e,n){e.exports=function(e){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}},Ijbi:function(e,n,t){var r=t("WkPL");e.exports=function(e){if(Array.isArray(e))return r(e)}},LUx3:function(e,n,t){"use strict";t.r(n),t.d(n,"meta",(function(){return b})),t.d(n,"default",(function(){return A}));var r=t("rePB");function a(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=t("q1tI"),s=t.n(o);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var u=s.a.createContext({}),h=function(e){var n=s.a.useContext(u),t=n;return e&&(t="function"===typeof e?e(n):c(c({},n),e)),t},d={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},f=s.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,i=p(e,["components","mdxType","originalType","parentName"]),l=h(t),u=r,f=l["".concat(o,".").concat(u)]||l[u]||d[u]||a;return t?s.a.createElement(f,c(c({ref:n},i),{},{components:t})):s.a.createElement(f,c({ref:n},i))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"===typeof e||r){var a=t.length,o=new Array(a);o[0]=f;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"===typeof e?e:r,o[1]=i;for(var c=2;c<a;c++)o[c]=t[c];return s.a.createElement.apply(null,o)}return s.a.createElement.apply(null,t)}f.displayName="MDXCreateElement";var y=t("nKUr"),g=t("8Kt/"),v=t.n(g),w=function(e){var n=e.meta,t=e.children;return Object(y.jsxs)(y.Fragment,{children:[Object(y.jsxs)(v.a,{children:[Object(y.jsxs)("title",{children:["Thanish.me - ",n.title]}),Object(y.jsx)("meta",{name:"description",content:n.info})]}),Object(y.jsx)("article",{children:Object(y.jsx)("main",{children:t})})]})};function O(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function S(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?O(Object(t),!0).forEach((function(n){Object(r.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):O(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var b={title:"Multiplayer Tetris Game",info:"A tutorial about writing a multiplayer game from scratch. Starting from solidifying the requirements and continues all the way up to creating a working prototype.",date:"2020-12-13",tags:["js"]},j={meta:b},k=function(e){var n=e.meta;return function(e){var t=e.children;return Object(y.jsx)(w,{meta:n,children:t})}}({meta:b});function A(e){var n=e.components,t=a(e,["components"]);return m(k,S(S(S({},j),t),{},{components:n,mdxType:"MDXLayout"}),m("h1",null,"Multiplayer Tetris Game"),m("p",null,"I just wanted to see what it would look like if multiple players try to play Tetris on the same canvas. Let's build this game in multiple rounds where the result of each iteration is a playable game."),m("img",{src:"/_next/static/images/1a44a319f1728cbd6fa1a9832c415ce6.png",width:"1000",height:"700",alt:"Tetris game concept"}),m("p",null,"These are our requirements for version 1:"),m("ul",null,m("li",{parentName:"ul"},"it should be possible for multiple players to play the game"),m("li",{parentName:"ul"},'it should support all the basic rules of a "Tetris" like game')),m("p",null,"This is what we're NOT doing for version 1:"),m("ul",null,m("li",{parentName:"ul"},"avoid support for playing with multiple devices, create a split-screen multiplayer game"),m("li",{parentName:"ul"},"avoid support for mobile devices, touch controls, etc.")),m("h2",null,"Basic Components"),m("p",null,"Before building, let's list down all the basic components. If we get this good enough, it may survive this version and some future versions of this game."),m("img",{src:"/_next/static/images/b18f86c32c28d07a727d3ceeb07b69a8.png",width:"1000",height:"400",alt:"Basic components of the game"}),m("p",null,"And we also need to define some rules to determine how it should behave. We may change these later but having some at the beginning makes it easy to develop."),m("ul",null,m("li",{parentName:"ul"},"All shapes in the game world must be visible on the screen."),m("li",{parentName:"ul"},"Shapes must not overlap with other shapes in the game world."),m("li",{parentName:"ul"},"When the game clock ticks, active shapes will move downwards. If they cannot move downwards they will become inactive."),m("li",{parentName:"ul"},"Players can move their active shapes left, right or rotate them using actions but only if there is enough empty space.")),m("p",null,"I guess that's enough to get us started. Let's convert what we have designed so far to code to see if it all makes any sense."),m("h2",null,"Writing the code"),m("p",null,"Let's start with a list of shape types. We can represent each shape type as a 2D array. The '1's represent filled blocks and the '0's will represent holes."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const SHAPE_TYPES = [\n  [\n    [1, 1],\n    [1, 1],\n  ],\n  [\n    [1, 0, 0],\n    [1, 1, 1],\n  ],\n  [\n    [0, 1, 0],\n    [1, 1, 1],\n  ],\n];\n")),m("p",null,"On the other end, we have the player. The most important thing we need from a player is to listen to actions from the player. So what are these actions? let's define actions as simple functions which manipulate the active shape. For example, the moveLeft and moveRight functions will modify the 'x' position of the shape."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const ACTION_TYPES = {\n  moveLeft: (shape) => {\n    shape.x--;\n  },\n\n  moveRight: (shape) => {\n    shape.x++;\n  },\n\n  moveDown: (shape) => {\n    shape.y++;\n  },\n\n  rotateShape: (shape) => {\n    const type = [];\n    for(let i = 0; i < shape.type[0].length; ++i) {\n      type[i] = [];\n      for(let j = 0; j < shape.type.length; ++j) {\n        type[i][j] = shape.type[shape.type.length - 1 - j][i];\n      }\n    }\n    shape.type = type;\n  },\n};\n")),m("p",null,"These actions are triggered by user interactions. We can map these actions to keys on the keyboard. Let's do it for 2 players."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const keymaps = [\n  {\n    KeyW: ACTION_TYPES.rotateShape,\n    KeyA: ACTION_TYPES.moveLeft,\n    KeyS: ACTION_TYPES.moveDown,\n    KeyD: ACTION_TYPES.moveRight,\n  },\n  {\n    ArrowUp: ACTION_TYPES.rotateShape,\n    ArrowLeft: ACTION_TYPES.moveLeft,\n    ArrowDown: ACTION_TYPES.moveDown,\n    ArrowRight: ACTION_TYPES.moveRight,\n  },\n];\n")),m("p",null,"The player holds a listener function and calls it when the user performs certain actions. It will need a listener function and a map of keycode => action functions. Because this adds an event listener, let's return a function which can be used to clean things up."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"// the returned function must be called to destroy the player\nconst startPlayer = (keymap, listener) => {\n  const keyDownListener = (e) => {\n    for (const key of Object.keys(keymap)) {\n      if (e.code === key) {\n        listener(keymap[key]);\n        break;\n      }\n    }\n  };\n  document.addEventListener('keydown', keyDownListener);\n\n  return () => {\n    document.removeEventListener('keydown', keyDownListener);\n  };\n};\n")),m("p",null,"And next, the game world. It will bring all the players and the shapes together and renders the output using the given renderer. Let's implement only the part where it listens to player actions and applies them on their active shapes and then renders the result."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const startWorld = (keymaps, renderer, options) => {\n  const PLAYER_COLORS = ['#6fa8dc', '#f6b26b'];\n  const playersCount = keymaps.length;\n  const playerShapes = [];\n  const stopPlayerFns = [];\n  const requestReRender = () => {\n    renderer(playerShapes);\n  };\n  const createNewShape = (i) => {\n    const index = Math.floor(Math.random() * SHAPE_TYPES.length);\n    const shape = { x: 0, y: 0, type: SHAPE_TYPES[index], color: '#111' };\n    shape.x = Math.floor((options.worldWidth / playersCount / 2) * (i * 2 + 1));\n    shape.color = PLAYER_COLORS[i % PLAYER_COLORS];\n    playerShapes[i].unshift(shape);\n    requestReRender();\n  };\n  const canPerformAction = (i, action) => {\n    // TODO: implement checks\n    return true;\n  };\n  const playerActionListener = (i, action) => {\n    if (!canPerformAction(i, action)) {\n      return;\n    }\n    const shape = playerShapes[i][0];\n    action(shape);\n    requestReRender();\n  };\n  for (let i = 0; i < playersCount; ++i) {\n    playerShapes[i] = [];\n    createNewShape(i);\n  }\n  for (let i = 0; i < playersCount; ++i) {\n    const keymap = keymaps[i];\n    const listener = (action) => playerActionListener(i, action);\n    stopPlayerFns[i] = startPlayer(keymap, listener);\n  }\n\n  return () => {\n    stopPlayerFns.forEach((fn) => fn());\n  };\n};\n")),m("p",null,"Let's see how it works with a test renderer."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const renderer = (shapes) => {\n  console.log('render:');\n  console.log(JSON.stringify(shapes[0]));\n  console.log(JSON.stringify(shapes[1]));\n};\nconst options = {\n  worldWidth: 32,\n};\nstartWorld(keymaps, renderer);\n")),m("p",null,"Seems to be working fine :)"),m("p",null,"Let's go ahead and create a simple canvas renderer so we can see what's going on."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const createRenderer = (canvas, options) => {\n  const canvasWidth = options.worldWidth * options.worldScale;\n  const canvasHeight = options.worldHeight * options.worldScale;\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n  const ctx = canvas.getContext('2d');\n\n  const renderBlock = (x, y, color) => {\n    ctx.fillStyle = color;\n    ctx.strokeStyle = '#000';\n    ctx.fillRect(\n      x * options.worldScale,\n      y * options.worldScale,\n      options.worldScale,\n      options.worldScale\n    );\n    ctx.strokeRect(\n      x * options.worldScale,\n      y * options.worldScale,\n      options.worldScale,\n      options.worldScale\n    );\n  };\n\n  const renderShape = (shape) => {\n    ctx.save();\n    ctx.translate(shape.x * options.worldScale, shape.y * options.worldScale);\n    for (let i = 0; i < shape.type.length; ++i) {\n      const row = shape.type[i];\n      for (let j = 0; j < row.length; ++j) {\n        if (row[j]) {\n          renderBlock(j, i, shape.color);\n        }\n      }\n    }\n    ctx.restore();\n  };\n\n  return (playerShapes) => {\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n    for (let i = 0; i < playerShapes.length; ++i) {\n      const shapes = playerShapes[i];\n      for (let j = 0; j < shapes.length; ++j) {\n        renderShape(shapes[j]);\n      }\n    }\n  };\n};\n")),m("p",null,'The end result looks something like this. Try pressing the "A", "D" keys on the keyboard while the iframe is in focus. It should move the shape left or right.'),m("iframe",{src:"2020-12-13-multiplayer-tetris-game/frames/version-1",width:"100%",height:"600",frameBorder:"none",scrolling:"no"}),m("p",null,"The next step is to make things move downwards. We can do that by moving the players active shape 1 unit downwards each second."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const startWorld = (keymaps, renderer, options) => {\n  // ...\n  const stopGameClock = ticker(() => {\n    for (let i = 0; i < playerShapes.length; ++i) {\n      playerActionListener(i, ACTION_TYPES.moveDown)\n    }\n  });\n  // ...\n\n  return () => {\n    stopGameClock();\n    // ...\n  };\n};\n")),m("p",null,"The next step is to add some rules to the game world. We can check against these rules before performing any actions. In some cases, rules may trigger the game to emit a new shape. Let's define what the rules can do."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const RULE_ACTIONS = {\n  BLOCK_ACTION: 1,\n  CREATE_SHAPE: 2,\n  END_THE_GAME: 3,\n};\n")),m("p",null,"And then change the player action listener to check the rules."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const startWorld = (keymaps, renderer, ticker, ruleset, options) => {\n  // ...\n  const playerActionListener = (i, action) => {\n    const activeShape = playerShapes[i][0];\n    const simulated = Object.create(activeShape);\n    action(simulated);\n    for (let j = 0; j < ruleset.length; ++j) {\n      const ruleFn = ruleset[j];\n      const result = ruleFn(simulated, activeShape, playerShapes);\n      if (result === RULE_ACTIONS.BLOCK_ACTION) {\n        return;\n      } else if (result === RULE_ACTIONS.CREATE_SHAPE) {\n        createNewShape(i);\n        return;\n      } else if (result === RULE_ACTIONS.END_THE_GAME) {\n        alert('GAME OVER!');\n        stopWorld();\n      }\n    }\n    action(activeShape);\n    requestReRender();\n  };\n  const stopGameClock = ticker(() => {\n    for (let i = 0; i < playerShapes.length; ++i) {\n      playerActionListener(i, ACTION_TYPES.moveDown);\n    }\n  });\n  const stopWorld = () => {\n    stopGameClock();\n    stopPlayerFns.forEach((fn) => fn());\n  };\n  // ...\n  return stopWorld;\n};\n")),m("p",null,"And add some rules to the game world."),m("pre",null,m("code",S({parentName:"pre"},{className:"language-js"}),"const createGameRules = (options) => {\n  const doesBBoxOverlap = (s1, s2) => {\n    if (\n      s1.x > s2.x + s2.type[0].length ||\n      s1.x + s1.type[0].length < s2.x ||\n      s1.y > s2.y + s2.type.length ||\n      s1.y + s1.type.length < s2.y\n    ) {\n      return false;\n    }\n    return true;\n  };\n  const doesBlockOverlap = (s1, row, col, s2) => {\n    if (!s1.type[row][col]) {\n      return false;\n    }\n    const s2row = row + s1.y - s2.y;\n    const s2col = col + s1.x - s2.x;\n    if (s2.type[s2row] && s2.type[s2row][s2col]) {\n      return true;\n    }\n    return false;\n  };\n  const getOtherShapes = function* (activeShape, playerShapes) {\n    for (let i = 0; i < playerShapes.length; ++i) {\n      const shapes = playerShapes[i];\n      for (let j = 0; j < shapes.length; ++j) {\n        const shape = shapes[j];\n        if (shape === activeShape) {\n          continue;\n        }\n        yield [shape, j === 0];\n      }\n    }\n  };\n  const isBlockedFromLeft = (simulated, activeShape, playerShapes) => {\n    if (simulated.type === activeShape.type && simulated.x >= activeShape.x) {\n      return null;\n    }\n    if (simulated.x < 0) {\n      return RULE_ACTIONS.BLOCK_ACTION;\n    }\n    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {\n      if (!doesBBoxOverlap(simulated, shape)) {\n        continue;\n      }\n      const col = 0;\n      for (let row = 0; row < simulated.type.length; ++row) {\n        if (doesBlockOverlap(simulated, row, col, shape)) {\n          return RULE_ACTIONS.BLOCK_ACTION;\n        }\n      }\n    }\n    return null;\n  };\n  const isBlockedFromRight = (simulated, activeShape, playerShapes) => {\n    if (simulated.type === activeShape.type && simulated.x <= activeShape.x) {\n      return null;\n    }\n    if (simulated.x + simulated.type[0].length > options.worldWidth) {\n      return RULE_ACTIONS.BLOCK_ACTION;\n    }\n    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {\n      if (!doesBBoxOverlap(simulated, shape)) {\n        continue;\n      }\n      const col = simulated.type[0].length - 1;\n      for (let row = 0; row < simulated.type.length; ++row) {\n        if (doesBlockOverlap(simulated, row, col, shape)) {\n          return RULE_ACTIONS.BLOCK_ACTION;\n        }\n      }\n    }\n    return null;\n  };\n  const isBlockedFromBottom = (simulated, activeShape, playerShapes) => {\n    if (simulated.type === activeShape.type && simulated.y <= activeShape.y) {\n      return null;\n    }\n    if (simulated.y + simulated.type.length > options.worldHeight) {\n      return RULE_ACTIONS.CREATE_SHAPE;\n    }\n    for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {\n      if (!doesBBoxOverlap(simulated, shape)) {\n        continue;\n      }\n      const row = simulated.type.length - 1;\n      for (let col = 0; col < simulated.type[0].length; ++col) {\n        if (doesBlockOverlap(simulated, row, col, shape)) {\n          if (simulated.y <= 0) {\n            return RULE_ACTIONS.END_THE_GAME;\n          }\n          if (isActive) {\n            return RULE_ACTIONS.BLOCK_ACTION;\n          }\n          return RULE_ACTIONS.CREATE_SHAPE;\n        }\n      }\n    }\n    return null;\n  };\n  return [isBlockedFromLeft, isBlockedFromRight, isBlockedFromBottom];\n};\n")),m("p",null,"The result looks like this. Please click on the button to start the game."),m("iframe",{src:"2020-12-13-multiplayer-tetris-game/frames/version-2",width:"100%",height:"600",frameBorder:"none",scrolling:"no"}),m("p",null,"We can stop it here for the MVP. There's a lot of work left to do which we'll cover in future blog posts."))}A.isMDXComponent=!0},RIqP:function(e,n,t){var r=t("Ijbi"),a=t("EbDI"),o=t("ZhPi"),s=t("Bnag");e.exports=function(e){return r(e)||a(e)||o(e)||s()}},Xuae:function(e,n,t){"use strict";var r=t("RIqP"),a=t("lwsE"),o=t("W8MJ"),s=(t("PJYZ"),t("7W2i")),i=t("a1gu"),l=t("Nsbk");function c(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,r=l(e);if(n){var a=l(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return i(this,t)}}n.__esModule=!0,n.default=void 0;var p=t("q1tI"),u=function(e){s(t,e);var n=c(t);function t(e){var o;return a(this,t),(o=n.call(this,e))._hasHeadManager=void 0,o.emitChange=function(){o._hasHeadManager&&o.props.headManager.updateHead(o.props.reduceComponentsToState(r(o.props.headManager.mountedInstances),o.props))},o._hasHeadManager=o.props.headManager&&o.props.headManager.mountedInstances,o}return o(t,[{key:"componentDidMount",value:function(){this._hasHeadManager&&this.props.headManager.mountedInstances.add(this),this.emitChange()}},{key:"componentDidUpdate",value:function(){this.emitChange()}},{key:"componentWillUnmount",value:function(){this._hasHeadManager&&this.props.headManager.mountedInstances.delete(this),this.emitChange()}},{key:"render",value:function(){return null}}]),t}(p.Component);n.default=u},lSNA:function(e,n){e.exports=function(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}},lwAK:function(e,n,t){"use strict";var r;n.__esModule=!0,n.AmpStateContext=void 0;var a=((r=t("q1tI"))&&r.__esModule?r:{default:r}).default.createContext({});n.AmpStateContext=a},rePB:function(e,n,t){"use strict";function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}t.d(n,"a",(function(){return r}))}}]);