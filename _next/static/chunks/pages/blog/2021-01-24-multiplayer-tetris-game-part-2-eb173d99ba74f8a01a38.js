_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[37],{"/QMM":function(e,t,n){"use strict";n.r(t),n.d(t,"meta",(function(){return u})),n.d(t,"default",(function(){return d}));var r=n("rePB"),a=n("Ff2n"),o=(n("q1tI"),n("7ljp")),i=n("hOk3"),s=n("RAYr");function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){Object(r.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={title:"Multiplayer Tetris Game (part 2)",description:"This tutorial validates the design we used to write code on part 1. We will try whether it's possible to fix bugs easily and whether we can add some new features to the game without major code/design changes.",intro:Object(o.a)("section",null,Object(o.a)("p",null,"This tutorial validates the design we used to write code on part 1. We will try whether it's possible to fix bugs easily and whether we can add some new features to the game without major code/design changes."),Object(o.a)("p",null,"Did it work? uou can try the updated game here (Instructions: click to focus and use \u2191\u2190\u2193\u2192 keys and WASD keys)"),Object(o.a)(s.a,{src:"/blog/2021-01-24-multiplayer-tetris-game-part-2/embed/finished",height:"400px",mdxType:"LazyIframe"})),date:"2021-01-24",tags:["js"]},p={meta:u},h=Object(i.a)({meta:u});function d(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.a)(h,c(c(c({},p),n),{},{components:t,mdxType:"MDXLayout"}),Object(o.a)("h2",null,"Fixing Bugs in the code"),Object(o.a)("p",null,'It turns out, the "T" shape passes through other shapes unless the block on the bottom touches. Let\'s have a look at one of the requirements we started with on part 1.'),Object(o.a)("ul",null,Object(o.a)("li",{parentName:"ul"},"R2.3: The active shape moves 1 unit downwards every 0.5 seconds until ",Object(o.a)("em",{parentName:"li"},"it lands")," on the floor or on another shape.")),Object(o.a)("p",null,"Let's define the requirement better."),Object(o.a)("ul",null,Object(o.a)("li",{parentName:"ul"},"R2.3: The active shape moves 1 unit downwards every 0.5 seconds until ",Object(o.a)("em",{parentName:"li"},"any of the blocks in the active shape lands")," on the floor or on another shape.")),Object(o.a)("p",null,"Here's the code that is supposed to handle this scenario."),Object(o.a)("pre",null,Object(o.a)("code",c({parentName:"pre"},{className:"language-js"}),"const isBlockedFromBottom = (simulated, activeShape, playerShapes) => {\n  if (simulated.type === activeShape.type && simulated.y <= activeShape.y) {\n    return null;\n  }\n  if (simulated.y + simulated.type.length > options.worldHeight) {\n    return RULE_ACTIONS.CREATE_SHAPE;\n  }\n  for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {\n    if (!doesBBoxOverlap(simulated, shape)) {\n      continue;\n    }\n    const row = simulated.type.length - 1;\n    for (let col = 0; col < simulated.type[0].length; ++col) {\n      if (doesBlockOverlap(simulated, row, col, shape)) {\n        if (simulated.y <= 0) {\n          return RULE_ACTIONS.END_THE_GAME;\n        }\n        if (isActive) {\n          return RULE_ACTIONS.BLOCK_ACTION;\n        }\n        return RULE_ACTIONS.CREATE_SHAPE;\n      }\n    }\n  }\n  return null;\n};\n")),Object(o.a)("p",null,"Instead of only checking the last row, we can check all the blocks with a bottom edge open.\nAnd here's the same code with the fix."),Object(o.a)("pre",null,Object(o.a)("code",c({parentName:"pre"},{className:"language-js"}),"const isBlockedFromBottom = (simulated, activeShape, playerShapes) => {\n  if (simulated.type === activeShape.type && simulated.y <= activeShape.y) {\n    return null;\n  }\n  if (simulated.y + simulated.type.length > options.worldHeight) {\n    return RULE_ACTIONS.CREATE_SHAPE;\n  }\n  for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {\n    if (!doesBBoxOverlap(simulated, shape)) {\n      continue;\n    }\n    for (let col = 0; col < simulated.type[0].length; ++col) {\n      let prevVal = 0;\n      for (let row = simulated.type.length - 1; row >= 0; --row) {\n        const val = simulated.type[row][col];\n        if (val && !prevVal) {\n          if (doesBlockOverlap(simulated, row, col, shape)) {\n            if (simulated.y <= 0) {\n              return RULE_ACTIONS.END_THE_GAME;\n            }\n            if (isActive) {\n              return RULE_ACTIONS.BLOCK_ACTION;\n            }\n            return RULE_ACTIONS.CREATE_SHAPE;\n          }\n        }\n        prevVal = val\n      }\n    }\n  }\n  return null;\n};\n")),Object(o.a)("p",null,"But how do we know that the change we made didn't affect any other scenarios which used to work until now? or if it affected any other parts of the app? or if it drastically slowed down the app?"),Object(o.a)("p",null,"This is one of the reasons why we need a proper set of tests for the app. Although it may seem like writing tests slows down development it usually pays off pretty fast."))}d.isMDXComponent=!0},RAYr:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n("rePB"),a=n("nKUr"),o=n("q1tI");function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){Object(r.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var l={container:{display:"flex",height:"600px",border:"dashed 1px #aaa",margin:"16px 0"},button:{flex:1,border:"none",background:"none",outline:"none",fontSize:"18px",cursor:"pointer"}},c=function(e){var t=e.src,n=e.height,r=Object(o.useState)(!1),i=r[0],c=r[1],u=Object(a.jsx)("iframe",{src:t,width:"100%",height:"100%",scrolling:"no"}),p=Object(a.jsx)("button",{style:l.button,onClick:function(){return c(!0)},children:"Click Here"});return Object(a.jsx)("div",{style:s(s({},l.container),{},{height:n}),children:i?u:p})}},zIbn:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/2021-01-24-multiplayer-tetris-game-part-2",function(){return n("/QMM")}])}},[["zIbn",0,1,2]]]);