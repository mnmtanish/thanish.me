_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[15],{K4Op:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/2014-05-24-aggregation-for-firebase",function(){return t("bHrx")}])},bHrx:function(e,a,t){"use strict";t.r(a),t.d(a,"meta",(function(){return u})),t.d(a,"default",(function(){return g}));var n=t("rePB"),r=t("Ff2n"),o=(t("q1tI"),t("7ljp")),s=t("hOk3");function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){Object(n.a)(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}var u={title:"Aggregation for Firebase",description:"Assume we need to create a realtime dashboard to show some summary  values. Usually, with Firebase, we'll have to get all data to the client  and process them there. But this can only work for small data sets. If  we have a few megabytes of data or more, this approach can get really  slow. And we must aggregate values on each and every client application  (web, mobile, etc).",intro:Object(o.a)("section",null,Object(o.a)("p",null,"Assume we need to create a realtime dashboard to show some summary  values. Usually, with Firebase, we'll have to get all data to the client  and process them there. But this can only work for small data sets. If  we have a few megabytes of data or more, this approach can get really  slow. And we must aggregate values on each and every client application  (web, mobile, etc).")),date:"2014-05-24",tags:["js","firebase"]},c={meta:u},d=Object(s.a)({meta:u});function g(e){var a=e.components,t=Object(r.a)(e,["components"]);return Object(o.a)(d,i(i(i({},c),t),{},{components:a,mdxType:"MDXLayout"}),Object(o.a)("p",null,"Assume we need to create a realtime dashboard to show some summary  values. Usually, with Firebase, we'll have to get all data to the client  and process them there. But this can only work for small data sets. If  we have a few megabytes of data or more, this approach can get really  slow. And we must aggregate values on each and every client application  (web, mobile, etc)."),Object(o.a)("p",null,"For this tutorial, both raw data and aggregated values will be stored  in Firebase. As an example let's find the total number of data items  per group (count) and sums of a few fields."),Object(o.a)("p",null,"To aggregate values, we'll write a simple application which runs on a  server or a Node.js PaaS and automatically aggregates our data. To make  things easier to use, we'll create a simple node module first. The  module will update aggregation results when data is added or removed.  The finished module will look like this."),Object(o.a)("pre",null,Object(o.a)("code",i({parentName:"pre"},{className:"language-js"}),"module.exports = function (opts) {\n  resetResults(function () {\n    opts.rawDataRef.on('child_added', function (snap) {\n      var data = snap.val();\n      var groupRef = getGroupRef(data);\n      groupRef.child('count').transaction(increment);\n      opts.fields.forEach(function (field) {\n        var value = data[field] || 0;\n        var totalRef = groupRef.child(field);\n        totalRef.transaction(function (total) {\n          return total + value;\n        });\n      });\n    });\n\n    opts.rawDataRef.on('child_removed', function (snap) {\n      var data = snap.val();\n      var groupRef = getGroupRef(data);\n      groupRef.child('count').transaction(decrement);\n      opts.fields.forEach(function (field) {\n        var value = data[field] || 0;\n        var totalRef = groupRef.child(field);\n        totalRef.transaction(function (total) {\n          return total - value;\n        });\n      });\n    });\n  })\n\n  function getGroupRef (data) {\n    var group = opts.groupFunction(data);\n    return opts.resultsRef.child(group);\n  }\n\n  function resetResults (callback) {\n    opts.resultsRef.set({}, callback);\n  }\n\n  function increment (value) {\n    return value + 1;\n  }\n\n  function decrement (value) {\n    return value - 1;\n  }\n}\n")),Object(o.a)("p",null,"It's not efficient to aggregate all data whenever something changes.  For our luck, Firebase gives us 2 important events child_added and  child_removed. This way, we can make the aggregation work almost  realtime and also reduce response time, data transfer and Firebase API  usage."),Object(o.a)("p",null,"First thing we need to do is reset data at resultsRef and listen to  child_added and child_removed events. If we check the child_added event,  first it updates the count and then finds the total for each field  given by the user and finally it updates the resultsRef."),Object(o.a)("p",null,"Whenever we need to aggregate some data, we can require this module  and use it. Here's an example which aggregates 2 fields and uses another  field to group them."),Object(o.a)("pre",null,Object(o.a)("code",i({parentName:"pre"},{className:"language-js"}),"var Firebase = require('firebase');\nvar FirebaseAggregator = require('./aggregator');\nvar rootUrl = 'https://aggregation-tutorial.firebaseio.com/';\nvar rootRef = new Firebase(rootUrl);\nvar rawDataRef = rootRef.child('rawData');\nvar resultsRef = rootRef.child('results');\n\nFirebaseAggregator({\n  rawDataRef: rawDataRef,\n  resultsRef: resultsRef,\n  fields: ['valueA', 'valueB'],\n  groupFunction: function (row) {\n    return row.group;\n  }\n});\n")),Object(o.a)("p",null,"The best thing about this approach is that we can run aggregation on  aggregated values. We can even have multiple levels (e.g. daily,  monthly, yearly) of aggregation. To test this out, create a Firebase  account and deploying the aggregation app on your own server or  someplace like Heroku."))}g.isMDXComponent=!0}},[["K4Op",0,1,2]]]);