_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[20],{PWj6:function(e,n,t){"use strict";t.r(n),t.d(n,"meta",(function(){return b})),t.d(n,"default",(function(){return p}));var a=t("rePB"),r=t("Ff2n"),o=(t("q1tI"),t("7ljp")),i=t("hOk3");function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){Object(a.a)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var b={title:"Limit Go Benchmark b.N",description:"**TLDR** - Operations count (b.N) can be set inside the function.",intro:Object(o.a)("section",null,Object(o.a)("p",null,"**TLDR** - Operations count (b.N) can be set inside the function.")),date:"2015-07-23",tags:["go"]},l={meta:b},m=Object(i.a)({meta:b});function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(o.a)(m,s(s(s({},l),t),{},{components:n,mdxType:"MDXLayout"}),Object(o.a)("p",null,Object(o.a)("strong",{parentName:"p"},"TLDR")," - Operations count (b.N) can be set inside the function."),Object(o.a)("p",null,"Go benchmarks can be extremely useful when attempting to write  performance critical applications. Both cpu and memory benchmarks can be  written for Go programs."),Object(o.a)("pre",null,Object(o.a)("code",s({parentName:"pre"},{className:"language-go"}),'func BenchmarkHello(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    fmt.Sprintf("hello")\n  }\n}\n')),Object(o.a)("p",null,"In the above example, the ",Object(o.a)("inlineCode",{parentName:"p"},"fmt.Sprintf")," function is run ",Object(o.a)("inlineCode",{parentName:"p"},"b.N")," times in order to get a good measurement. The ",Object(o.a)("inlineCode",{parentName:"p"},"b.N")," is usually a large number sometimes can exceed millions. Go benchmarks usually start with a small number for ",Object(o.a)("inlineCode",{parentName:"p"},"b.N")," and it's increased while running the benchmark until the benchmark is  run for a certain time. The benchmark time can be changed by setting the ",Object(o.a)("inlineCode",{parentName:"p"},"-benchtime")," argument when running the test. This can be demonstrated by this simple benchmark."),Object(o.a)("pre",null,Object(o.a)("code",s({parentName:"pre"},{className:"language-go"}),'func BenchmarkZero(b *testing.B) {\n  fmt.Println("N =", b.N)\n  sleepForNs(b.N)\n}\n')),Object(o.a)("p",null,"As expected, go will run this benchmark function multiple times increasing ",Object(o.a)("inlineCode",{parentName:"p"},"b.N")," each time until required time is reached. Logs from the test will be similar to the log given below."),Object(o.a)("pre",null,Object(o.a)("code",s({parentName:"pre"},{}),"testing: warning: no tests to run\nPASS\nBenchmarkHello  N = 1\nN = 100\nN = 10000\nN = 1000000\nN = 100000000\nN = 2000000000\n2000000000           1.00 ns/op\nok      temporary/test  2.117s\n\n")),Object(o.a)("p",null,Object(o.a)("strong",{parentName:"p"},"In some cases it's not feasible to run a benchmark that number of times."),' For an example, if the benchmark involves writing data to the disk,  benchmarks would often crash with a "too many open files" error.'),Object(o.a)("p",null,"Being able to limit benchmark operations count makes it possible to  write benchmarks for even more complex code. Unfortunately although  there's an argument to set the benchmark time and none for setting the  count. Limiting benchmark count is extremely easy it would be silly to  write a blog post on it if it's documented. It can be set simply by  changing ",Object(o.a)("inlineCode",{parentName:"p"},"b.N")," inside the benchmark to an appropriate number.  The above example benchmark can be compared to one where we've set the  number of Ops to verify."),Object(o.a)("pre",null,Object(o.a)("code",s({parentName:"pre"},{className:"language-go"}),'package test\n\nimport (\n    "fmt"\n    "testing"\n)\n\nfunc BenchmarkOne(b *testing.B) {\n    b.N = b.N + 1 - 1\n    fmt.Println("N =", b.N)\n    sleepForNs(b.N * 1000)\n}\n\nfunc BenchmarkTwo(b *testing.B) {\n    b.N = b.N + 100000 - b.N\n    fmt.Println("N =", b.N)\n    sleepForNs(b.N * 1000)\n}\n')),Object(o.a)("p",null,"The output would be similar to this:"),Object(o.a)("pre",null,Object(o.a)("code",s({parentName:"pre"},{}),"testing: warning: no tests to run\nPASS\nBenchmarkOne    N = 1\nN = 100\nN = 10000\nN = 1000000\n 1000000        1003 ns/op\nBenchmarkTwo    N = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\nN = 100000\n  100000        1001 ns/op\nok      temporary/test  2.672s\n\n")),Object(o.a)("p",null,"We can clearly see that this doesn't affect the benchmark results as  both versions take approximately 1000s/op. The second benchmark function  had to be run more times in order to fill the required time period."),Object(o.a)("p",null,"This method is tested only on Go v1.4 (latest stable version). Please  note that this is feature was not documented  therefore it can change  and may not work the same way on other Go versions."))}p.isMDXComponent=!0},"ZU+K":function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/2015-07-23-limit-go-benchmark-b-n",function(){return t("PWj6")}])}},[["ZU+K",0,1,2]]]);