<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><title>Thanish.me - Multiplayer Tetris Game (part 1)</title><meta name="description"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/5a2baf7224eaa76eb18a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5a2baf7224eaa76eb18a.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-e3975b6d7e1772f0387e.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.cdbdac0a36200f52203c.js" as="script"/><link rel="preload" href="/_next/static/chunks/4f088cdd89df94f4217543aeda569c5b1b625012.d18b4cd5b9181f9df943.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.c6a4334a2b3b42359535.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ff3a7e7bcf69eb214640.js" as="script"/><link rel="preload" href="/_next/static/chunks/b0ccf173e2b8877c2800d77594052a2594447d32.eb260416e34d3158d8cd.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/2020-12-13-multiplayer-tetris-game-part-1-6725e936fc7829206f3c.js" as="script"/></head><body><div id="__next"><main><content class="markdown-body"><article><header><h1>Multiplayer Tetris Game (part 1)</h1><main><section><p>A tutorial about writing a multiplayer game from scratch. Starting from solidifying the requirements and continues all the way up to creating a working prototype with vanilla js. By the end of the tutorial we will have the following game.</p><div style="display:flex;height:400px;border:dashed 1px #aaa;margin:16px 0"><button style="flex:1;border:none;background:none;outline:none;font-size:18px;cursor:pointer">Click Here</button></div><p style="text-align:center"><strong>Press `W, A, S, D` keys or the arrow keys to play</strong></p></section></main></header><main><h2>Before We Start</h2><p>At a high level, these are our requirements for the game we&#x27;re building with this tutorial. This is something similar to what we would get as requirements from an end user.</p><h3>Requirements for Version 1</h3><ul><li>R1: it should be possible for multiple players to play the game</li><li>R2: it should support all the basic rules of a &quot;Tetris like&quot; game</li></ul><p>Let&#x27;s break these down further and decide how we&#x27;re going to solve these. I&#x27;m pretty sure we probably have this on our minds but it helps to write these things down.</p><h4>&quot;R1: it should be possible for multiple players to play the game&quot;</h4><p>There are many ways to do this. We&#x27;ll go old school and build a &quot;split-screen&quot; multiplayer game. This way we don&#x27;t need to build any server side components.</p><h4>&quot;R2: it should support all the basic rules of a &quot;Tetris like&quot; game&quot;</h4><p>What are rules of a tetris like game? let&#x27;s work on this while we are building the game. We can add a few to get started.</p><ul><li>R2.1: Shapes should never overlap with other shapes in the game.</li><li>R2.2: There is an &quot;active shape&quot; per player which can be rotated or moved left, right and down by the player.</li><li>R2.3: The active shape moves 1 unit downwards every 0.5 seconds until it lands on the floor or on another shape.</li><li>R2.4: A new shape is added when the game starts and when the active shape can no longer move downwards.</li><li>R2.5: When a new shape is added, it becomes the active shape and the previous active shape becomes inactive.</li><li>R2.6: The game is over when the shapes reaches the game world ceiling.</li></ul><h2>Basic Components</h2><p>Before building, let&#x27;s list down all the basic components. If we get this good enough, it may survive this version and some future versions of this game. Making changes here will usually take more time than changing other parts of the code.</p><img src="/_next/static/images/b18f86c32c28d07a727d3ceeb07b69a8.png" width="1000" height="400" alt="Basic components of the game"/><h3>Shapes and Shape Types</h3><p>In the game world, a shape would have a position and a type. It also needs a color so different players can have different colors. And we can change the color to represent other states as well (inactive?).</p><pre><code class="language-ts">interface Shape {
  x: number;
  y: number;
  type: ShapeType;
  color: string;
}
</code></pre><p>We can represent each shape type as a 2D array. The &#x27;1&#x27;s represent filled blocks and the &#x27;0&#x27;s will represent holes.</p><pre><code class="language-ts">type ShapeType = number[][];
</code></pre><p>And some example shape types we can use in the game. We have the square, &quot;L&quot;, &quot;T&quot; and the &quot;I&quot; in order.</p><pre><code class="language-ts">const SHAPE_TYPES: ShapeType[] = [
  [
    [1, 1],
    [1, 1],
  ],
  [
    [1, 0, 0],
    [1, 1, 1],
  ],
  [
    [0, 1, 0],
    [1, 1, 1],
  ],
  [[1, 1, 1]],
];
</code></pre><h3>Actions from the Player</h3><p>Let&#x27;s define actions as simple functions which modify the active shape. For example, the moveLeft and moveRight functions will modify the &#x27;x&#x27; position of the shape.</p><pre><code class="language-ts">type PlayerAction = (shape: Shape) =&gt; void;
</code></pre><p>And some example player actions we can use in the game.</p><pre><code class="language-ts">const ACTION_TYPES: { [name: string]: PlayerAction } = {
  moveLeft: (shape) =&gt; {
    shape.x--;
  },

  moveRight: (shape) =&gt; {
    shape.x++;
  },

  moveDown: (shape) =&gt; {
    shape.y++;
  },

  rotateShape: (shape) =&gt; {
    const type = [];
    for (let i = 0; i &lt; shape.type[0].length; ++i) {
      type[i] = [];
      for (let j = 0; j &lt; shape.type.length; ++j) {
        type[i][j] = shape.type[shape.type.length - 1 - j][i];
      }
    }
    shape.type = type;
  },
};
</code></pre><p>These actions are triggered by user interactions. We can map these actions to keys on the keyboard. Let&#x27;s do it for 2 players.</p><pre><code class="language-ts">type PlayerKeymap = { [key: string]: PlayerAction };

const PLAYER_KEYMAPS: PlayerKeymap[] = [
  {
    KeyW: ACTION_TYPES.rotateShape,
    KeyA: ACTION_TYPES.moveLeft,
    KeyS: ACTION_TYPES.moveDown,
    KeyD: ACTION_TYPES.moveRight,
  },
  {
    ArrowUp: ACTION_TYPES.rotateShape,
    ArrowLeft: ACTION_TYPES.moveLeft,
    ArrowDown: ACTION_TYPES.moveDown,
    ArrowRight: ACTION_TYPES.moveRight,
  },
];
</code></pre><h3>Inside the Game World</h3><p>There are several sub components in the game world, let&#x27;s define them one by one. And also explain why we need them.</p><h4>The Game Clock</h4><p>The game world takes input from player actions and also from the game clock. When the clock &quot;ticks&quot; we move the active shape down. This is one of the requirements of the game (R2.3). The clock only needs to execute a given function for each tick.</p><pre><code class="language-ts">type GameClock = (fn: () =&gt; void) =&gt; void;
</code></pre><h4>The Game Rules</h4><p>Next we need some way to filter player actions. Given a player action the rule should decide whether we should apply it or not.</p><pre><code class="language-ts">// TODO: would probably need more information to decide the outcome
type GameRule = (action: PlayerAction) =&gt; &#x27;apply&#x27; | &#x27;dont_apply&#x27;;
</code></pre><h4>The Game Renderer</h4><p>The render receives an array of shapes to render in the game. We can group them by player so the renderer receives more information.</p><pre><code class="language-ts">type GameRenderer = (shapesets: Shape[][]) =&gt; void;
</code></pre><h2>Let&#x27;s write the code</h2><p>We will use the types we defined before but we will make changes if we need to.</p><h3>Listening to Player Actions</h3><p>The player receives a listener function and calls it when the user performs actions. It will need a listener function and a map of keycode =&gt; action functions. Because this adds an event listener, let&#x27;s return a function which can be used to clean things up.</p><pre><code class="language-js">// the returned function must be called to destroy the player
const startPlayer = (keymap, listener) =&gt; {
  const keyDownListener = (e) =&gt; {
    for (const key of Object.keys(keymap)) {
      if (e.code === key) {
        listener(keymap[key]);
        break;
      }
    }
  };
  document.addEventListener(&#x27;keydown&#x27;, keyDownListener);

  return () =&gt; {
    document.removeEventListener(&#x27;keydown&#x27;, keyDownListener);
  };
};
</code></pre><p>And next, the game world. It will bring all the players and the shapes together and renders the output using the given renderer. Let&#x27;s implement only the part where it listens to player actions and applies them on their active shapes and then renders the result.</p><p>We also added an options object which we can use to configure the game world. Right now, it only has the world&#x27;s width.</p><pre><code class="language-js">const startWorld = (keymaps, renderer, options) =&gt; {
  const PLAYER_COLORS = [&#x27;#6fa8dc&#x27;, &#x27;#f6b26b&#x27;];
  const playersCount = keymaps.length;
  const playerShapes = [];
  const stopPlayerFns = [];
  const requestReRender = () =&gt; {
    renderer(playerShapes);
  };
  const createNewShape = (i) =&gt; {
    const index = Math.floor(Math.random() * SHAPE_TYPES.length);
    const shape = { x: 0, y: 0, type: SHAPE_TYPES[index], color: &#x27;#111&#x27; };
    shape.x = Math.floor((options.worldWidth / playersCount / 2) * (i * 2 + 1));
    shape.color = PLAYER_COLORS[i % PLAYER_COLORS];
    playerShapes[i].unshift(shape);
    requestReRender();
  };
  const canPerformAction = (i, action) =&gt; {
    // TODO: implement checks
    return true;
  };
  const playerActionListener = (i, action) =&gt; {
    if (!canPerformAction(i, action)) {
      return;
    }
    const shape = playerShapes[i][0];
    action(shape);
    requestReRender();
  };
  for (let i = 0; i &lt; playersCount; ++i) {
    playerShapes[i] = [];
    createNewShape(i);
  }
  for (let i = 0; i &lt; playersCount; ++i) {
    const keymap = keymaps[i];
    const listener = (action) =&gt; playerActionListener(i, action);
    stopPlayerFns[i] = startPlayer(keymap, listener);
  }

  return () =&gt; {
    stopPlayerFns.forEach((fn) =&gt; fn());
  };
};
</code></pre><p>Let&#x27;s see how it works with a test renderer.</p><pre><code class="language-js">const renderer = (shapes) =&gt; {
  console.log(&#x27;render:&#x27;);
  console.log(JSON.stringify(shapes[0]));
  console.log(JSON.stringify(shapes[1]));
};
const options = {
  worldWidth: 32,
};
startWorld(keymaps, renderer);
</code></pre><p>Seems to be working fine :)</p><h3>Adding a Canvas Renderer</h3><p>Let&#x27;s go ahead and create a simple canvas renderer so we can see what&#x27;s going on. We also added <code>worldHeight</code> and <code>worldScale</code> to the options object.</p><pre><code class="language-js">const createRenderer = (canvas, options) =&gt; {
  const canvasWidth = options.worldWidth * options.worldScale;
  const canvasHeight = options.worldHeight * options.worldScale;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext(&#x27;2d&#x27;);

  const renderBlock = (x, y, color) =&gt; {
    ctx.fillStyle = color;
    ctx.strokeStyle = &#x27;#000&#x27;;
    ctx.fillRect(
      x * options.worldScale,
      y * options.worldScale,
      options.worldScale,
      options.worldScale
    );
    ctx.strokeRect(
      x * options.worldScale,
      y * options.worldScale,
      options.worldScale,
      options.worldScale
    );
  };

  const renderShape = (shape) =&gt; {
    ctx.save();
    ctx.translate(shape.x * options.worldScale, shape.y * options.worldScale);
    for (let i = 0; i &lt; shape.type.length; ++i) {
      const row = shape.type[i];
      for (let j = 0; j &lt; row.length; ++j) {
        if (row[j]) {
          renderBlock(j, i, shape.color);
        }
      }
    }
    ctx.restore();
  };

  return (playerShapes) =&gt; {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    for (let i = 0; i &lt; playerShapes.length; ++i) {
      const shapes = playerShapes[i];
      for (let j = 0; j &lt; shapes.length; ++j) {
        renderShape(shapes[j]);
      }
    }
  };
};
</code></pre><h3>Adding Gravity and Other Rules</h3><p>The next step is to make things move downwards. Let&#x27;s apply these changes to the <code>startWorld</code> function.</p><pre><code class="language-js">const startWorld = (keymaps, renderer, ticker, options) =&gt; {
  // ...
  const stopGameClock = ticker(() =&gt; {
    for (let i = 0; i &lt; playerShapes.length; ++i) {
      playerActionListener(i, ACTION_TYPES.moveDown);
    }
  });
  // ...

  return () =&gt; {
    stopGameClock();
    // ...
  };
};
</code></pre><p>The next step is to add some rules to the game world. We can check against these rules before performing any actions. In some cases, rules may trigger the game to emit a new shape. Let&#x27;s define what the rules can do.</p><pre><code class="language-js">const RULE_ACTIONS = {
  BLOCK_ACTION: 1,
  CREATE_SHAPE: 2,
  END_THE_GAME: 3,
};
</code></pre><p>And then change the player action listener to check the rules.</p><pre><code class="language-js">const startWorld = (keymaps, renderer, ticker, ruleset, options) =&gt; {
  // ...
  const playerActionListener = (i, action) =&gt; {
    const activeShape = playerShapes[i][0];
    const simulated = Object.create(activeShape);
    action(simulated);
    for (let j = 0; j &lt; ruleset.length; ++j) {
      const ruleFn = ruleset[j];
      const result = ruleFn(simulated, activeShape, playerShapes);
      if (result === RULE_ACTIONS.BLOCK_ACTION) {
        return;
      } else if (result === RULE_ACTIONS.CREATE_SHAPE) {
        createNewShape(i);
        return;
      } else if (result === RULE_ACTIONS.END_THE_GAME) {
        alert(&#x27;GAME OVER!&#x27;);
        stopWorld();
      }
    }
    action(activeShape);
    requestReRender();
  };
  const stopGameClock = ticker(() =&gt; {
    for (let i = 0; i &lt; playerShapes.length; ++i) {
      playerActionListener(i, ACTION_TYPES.moveDown);
    }
  });
  const stopWorld = () =&gt; {
    stopGameClock();
    stopPlayerFns.forEach((fn) =&gt; fn());
  };
  // ...
  return stopWorld;
};
</code></pre><p>And add some rules to the game world.</p><pre><code class="language-js">const createGameRules = (options) =&gt; {
  const doesBBoxOverlap = (s1, s2) =&gt; {
    if (
      s1.x &gt; s2.x + s2.type[0].length ||
      s1.x + s1.type[0].length &lt; s2.x ||
      s1.y &gt; s2.y + s2.type.length ||
      s1.y + s1.type.length &lt; s2.y
    ) {
      return false;
    }
    return true;
  };
  const doesBlockOverlap = (s1, row, col, s2) =&gt; {
    if (!s1.type[row][col]) {
      return false;
    }
    const s2row = row + s1.y - s2.y;
    const s2col = col + s1.x - s2.x;
    if (s2.type[s2row] &amp;&amp; s2.type[s2row][s2col]) {
      return true;
    }
    return false;
  };
  const getOtherShapes = function* (activeShape, playerShapes) {
    for (let i = 0; i &lt; playerShapes.length; ++i) {
      const shapes = playerShapes[i];
      for (let j = 0; j &lt; shapes.length; ++j) {
        const shape = shapes[j];
        if (shape === activeShape) {
          continue;
        }
        yield [shape, j === 0];
      }
    }
  };
  const isBlockedFromLeft = (simulated, activeShape, playerShapes) =&gt; {
    if (simulated.type === activeShape.type &amp;&amp; simulated.x &gt;= activeShape.x) {
      return null;
    }
    if (simulated.x &lt; 0) {
      return RULE_ACTIONS.BLOCK_ACTION;
    }
    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const col = 0;
      for (let row = 0; row &lt; simulated.type.length; ++row) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          return RULE_ACTIONS.BLOCK_ACTION;
        }
      }
    }
    return null;
  };
  const isBlockedFromRight = (simulated, activeShape, playerShapes) =&gt; {
    if (simulated.type === activeShape.type &amp;&amp; simulated.x &lt;= activeShape.x) {
      return null;
    }
    if (simulated.x + simulated.type[0].length &gt; options.worldWidth) {
      return RULE_ACTIONS.BLOCK_ACTION;
    }
    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const col = simulated.type[0].length - 1;
      for (let row = 0; row &lt; simulated.type.length; ++row) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          return RULE_ACTIONS.BLOCK_ACTION;
        }
      }
    }
    return null;
  };
  const isBlockedFromBottom = (simulated, activeShape, playerShapes) =&gt; {
    if (simulated.type === activeShape.type &amp;&amp; simulated.y &lt;= activeShape.y) {
      return null;
    }
    if (simulated.y + simulated.type.length &gt; options.worldHeight) {
      return RULE_ACTIONS.CREATE_SHAPE;
    }
    for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const row = simulated.type.length - 1;
      for (let col = 0; col &lt; simulated.type[0].length; ++col) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          if (simulated.y &lt;= 0) {
            return RULE_ACTIONS.END_THE_GAME;
          }
          if (isActive) {
            return RULE_ACTIONS.BLOCK_ACTION;
          }
          return RULE_ACTIONS.CREATE_SHAPE;
        }
      }
    }
    return null;
  };
  return [isBlockedFromLeft, isBlockedFromRight, isBlockedFromBottom];
};
</code></pre><h2>Are we there yet?</h2><p>The code we have written so far brings us to this:</p><div style="display:flex;height:400px;border:dashed 1px #aaa;margin:16px 0"><button style="flex:1;border:none;background:none;outline:none;font-size:18px;cursor:pointer">Click Here</button></div><p>We can stop it here for the MVP. There&#x27;s a lot of work left to do which we&#x27;ll cover in future blog posts.</p></main></article></content></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/2020-12-13-multiplayer-tetris-game-part-1","query":{},"buildId":"uLDgB4eTyhcwpGuDJHgPg","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-fa276ba060a4a8ac7eef.js"></script><script src="/_next/static/chunks/main-e3975b6d7e1772f0387e.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.cdbdac0a36200f52203c.js" async=""></script><script src="/_next/static/chunks/4f088cdd89df94f4217543aeda569c5b1b625012.d18b4cd5b9181f9df943.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.c6a4334a2b3b42359535.js" async=""></script><script src="/_next/static/chunks/pages/_app-ff3a7e7bcf69eb214640.js" async=""></script><script src="/_next/static/chunks/b0ccf173e2b8877c2800d77594052a2594447d32.eb260416e34d3158d8cd.js" async=""></script><script src="/_next/static/chunks/pages/blog/2020-12-13-multiplayer-tetris-game-part-1-6725e936fc7829206f3c.js" async=""></script><script src="/_next/static/uLDgB4eTyhcwpGuDJHgPg/_buildManifest.js" async=""></script><script src="/_next/static/uLDgB4eTyhcwpGuDJHgPg/_ssgManifest.js" async=""></script></body></html>