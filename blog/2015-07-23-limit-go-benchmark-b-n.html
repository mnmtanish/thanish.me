<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><title>Thanish.me - Limit Go Benchmark b.N</title><meta name="description" content="**TLDR** - Operations count (b.N) can be set inside the function."/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/f2de525f08037cbc6b9e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f2de525f08037cbc6b9e.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/afe4269f325c6b8604421e2a8f7bec7a7b2019c2.e5ebd9a9dc48937a5931.js" as="script"/><link rel="preload" href="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.75924e07078b24214e9e.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-e37b7be6f8e64920e240.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ca60ee2a73a7be766260.js" as="script"/><link rel="preload" href="/_next/static/chunks/ec66151a9e4e24d8cdbbe349a286441475ff64c5.35a602b2b7b41dfb8d3c.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/2015-07-23-limit-go-benchmark-b-n-eb81528e545fcdd2996f.js" as="script"/></head><body><div id="__next"><main class="markdown-body"><article><header class="page-header"><a href="/" class="page-header-title">Thanish.me</a><a href="/" class="page-header-subtitle">dd if=/dev/head of=/dev/blog</a></header><header><h1 class="post-head">Limit Go Benchmark b.N</h1><p class="post-meta"><small>Posted on <!-- -->2015-07-23</small></p><main><section><p>**TLDR** - Operations count (b.N) can be set inside the function.</p></section></main></header><main><p><strong>TLDR</strong> - Operations count (b.N) can be set inside the function.</p><p>Go benchmarks can be extremely useful when attempting to write  performance critical applications. Both cpu and memory benchmarks can be  written for Go programs.</p><pre><code class="language-go">func BenchmarkHello(b *testing.B) {
  for i := 0; i &lt; b.N; i++ {
    fmt.Sprintf(&quot;hello&quot;)
  }
}
</code></pre><p>In the above example, the <code>fmt.Sprintf</code> function is run <code>b.N</code> times in order to get a good measurement. The <code>b.N</code> is usually a large number sometimes can exceed millions. Go benchmarks usually start with a small number for <code>b.N</code> and it&#x27;s increased while running the benchmark until the benchmark is  run for a certain time. The benchmark time can be changed by setting the <code>-benchtime</code> argument when running the test. This can be demonstrated by this simple benchmark.</p><pre><code class="language-go">func BenchmarkZero(b *testing.B) {
  fmt.Println(&quot;N =&quot;, b.N)
  sleepForNs(b.N)
}
</code></pre><p>As expected, go will run this benchmark function multiple times increasing <code>b.N</code> each time until required time is reached. Logs from the test will be similar to the log given below.</p><pre><code>testing: warning: no tests to run
PASS
BenchmarkHello  N = 1
N = 100
N = 10000
N = 1000000
N = 100000000
N = 2000000000
2000000000           1.00 ns/op
ok      temporary/test  2.117s

</code></pre><p><strong>In some cases it&#x27;s not feasible to run a benchmark that number of times.</strong> For an example, if the benchmark involves writing data to the disk,  benchmarks would often crash with a &quot;too many open files&quot; error.</p><p>Being able to limit benchmark operations count makes it possible to  write benchmarks for even more complex code. Unfortunately although  there&#x27;s an argument to set the benchmark time and none for setting the  count. Limiting benchmark count is extremely easy it would be silly to  write a blog post on it if it&#x27;s documented. It can be set simply by  changing <code>b.N</code> inside the benchmark to an appropriate number.  The above example benchmark can be compared to one where we&#x27;ve set the  number of Ops to verify.</p><pre><code class="language-go">package test

import (
    &quot;fmt&quot;
    &quot;testing&quot;
)

func BenchmarkOne(b *testing.B) {
    b.N = b.N + 1 - 1
    fmt.Println(&quot;N =&quot;, b.N)
    sleepForNs(b.N * 1000)
}

func BenchmarkTwo(b *testing.B) {
    b.N = b.N + 100000 - b.N
    fmt.Println(&quot;N =&quot;, b.N)
    sleepForNs(b.N * 1000)
}
</code></pre><p>The output would be similar to this:</p><pre><code>testing: warning: no tests to run
PASS
BenchmarkOne    N = 1
N = 100
N = 10000
N = 1000000
 1000000        1003 ns/op
BenchmarkTwo    N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
N = 100000
  100000        1001 ns/op
ok      temporary/test  2.672s

</code></pre><p>We can clearly see that this doesn&#x27;t affect the benchmark results as  both versions take approximately 1000s/op. The second benchmark function  had to be run more times in order to fill the required time period.</p><p>This method is tested only on Go v1.4 (latest stable version). Please  note that this is feature was not documented  therefore it can change  and may not work the same way on other Go versions.</p></main></article></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/2015-07-23-limit-go-benchmark-b-n","query":{},"buildId":"LBoss_3bTEnpbr99JDv_S","nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-e479c6e9625ada71bd60.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/afe4269f325c6b8604421e2a8f7bec7a7b2019c2.e5ebd9a9dc48937a5931.js" async=""></script><script src="/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.75924e07078b24214e9e.js" async=""></script><script src="/_next/static/chunks/main-e37b7be6f8e64920e240.js" async=""></script><script src="/_next/static/chunks/pages/_app-ca60ee2a73a7be766260.js" async=""></script><script src="/_next/static/chunks/ec66151a9e4e24d8cdbbe349a286441475ff64c5.35a602b2b7b41dfb8d3c.js" async=""></script><script src="/_next/static/chunks/pages/blog/2015-07-23-limit-go-benchmark-b-n-eb81528e545fcdd2996f.js" async=""></script><script src="/_next/static/LBoss_3bTEnpbr99JDv_S/_buildManifest.js" async=""></script><script src="/_next/static/LBoss_3bTEnpbr99JDv_S/_ssgManifest.js" async=""></script></body></html>