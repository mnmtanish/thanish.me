import { createPostContent } from 'theme/PostContent';
import imgTetrisGame from './images/tetris-game.png';
import imgBasicComponents from './images/basic-components.png';

export const meta = {
  title: 'Multiplayer Tetris Game',
  info:
    'A tutorial about writing a multiplayer game from scratch. Starting from solidifying the requirements and continues all the way up to creating a working prototype.',
  date: '2020-12-13',
  tags: ['js'],
};

export default createPostContent({ meta });

# Multiplayer Tetris Game

I just wanted to see what it would look like if multiple players try to play Tetris on the same canvas. Let's build this game in multiple rounds where the result of each iteration is a playable game.

<img src={imgTetrisGame} width="1000" height="700" alt="Tetris game concept" />

These are our requirements for version 1:

- it should be possible for multiple players to play the game
- it should support all the basic rules of a "Tetris" like game

This is what we're NOT doing for version 1:

- avoid support for playing with multiple devices, create a split-screen multiplayer game
- avoid support for mobile devices, touch controls, etc.

## Basic Components

Before building, let's list down all the basic components. If we get this good enough, it may survive this version and some future versions of this game.

<img
  src={imgBasicComponents}
  width="1000"
  height="400"
  alt="Basic components of the game"
/>

And we also need to define some rules to determine how it should behave. We may change these later but having some at the beginning makes it easy to develop.

- All shapes in the game world must be visible on the screen.
- Shapes must not overlap with other shapes in the game world.
- When the game clock ticks, active shapes will move downwards. If they cannot move downwards they will become inactive.
- Players can move their active shapes left, right or rotate them using actions but only if there is enough empty space.

I guess that's enough to get us started. Let's convert what we have designed so far to code to see if it all makes any sense.

## Writing the code

Let's start with a list of shape types. We can represent each shape type as a 2D array. The '1's represent filled blocks and the '0's will represent holes.

```js
const SHAPE_TYPES = [
  [
    [1, 1],
    [1, 1],
  ],
  [
    [1, 0, 0],
    [1, 1, 1],
  ],
  [
    [0, 1, 0],
    [1, 1, 1],
  ],
];
```

On the other end, we have the player. The most important thing we need from a player is to listen to actions from the player. So what are these actions? let's define actions as simple functions which manipulate the active shape. For example, the moveLeft and moveRight functions will modify the 'x' position of the shape.

```js
const ACTION_TYPES = {
  moveLeft: (shape) => {
    shape.x--;
  },

  moveRight: (shape) => {
    shape.x++;
  },

  moveDown: (shape) => {
    shape.y++;
  },

  rotateShape: (shape) => {
    const type = [];
    for(let i = 0; i < shape.type[0].length; ++i) {
      type[i] = [];
      for(let j = 0; j < shape.type.length; ++j) {
        type[i][j] = shape.type[shape.type.length - 1 - j][i];
      }
    }
    shape.type = type;
  },
};
```

These actions are triggered by user interactions. We can map these actions to keys on the keyboard. Let's do it for 2 players.

```js
const keymaps = [
  {
    KeyW: ACTION_TYPES.rotateShape,
    KeyA: ACTION_TYPES.moveLeft,
    KeyS: ACTION_TYPES.moveDown,
    KeyD: ACTION_TYPES.moveRight,
  },
  {
    ArrowUp: ACTION_TYPES.rotateShape,
    ArrowLeft: ACTION_TYPES.moveLeft,
    ArrowDown: ACTION_TYPES.moveDown,
    ArrowRight: ACTION_TYPES.moveRight,
  },
];
```

The player holds a listener function and calls it when the user performs certain actions. It will need a listener function and a map of keycode => action functions. Because this adds an event listener, let's return a function which can be used to clean things up.

```js
// the returned function must be called to destroy the player
const startPlayer = (keymap, listener) => {
  const keyDownListener = (e) => {
    for (const key of Object.keys(keymap)) {
      if (e.code === key) {
        listener(keymap[key]);
        break;
      }
    }
  };
  document.addEventListener('keydown', keyDownListener);

  return () => {
    document.removeEventListener('keydown', keyDownListener);
  };
};
```

And next, the game world. It will bring all the players and the shapes together and renders the output using the given renderer. Let's implement only the part where it listens to player actions and applies them on their active shapes and then renders the result.

```js
const startWorld = (keymaps, renderer, options) => {
  const PLAYER_COLORS = ['#6fa8dc', '#f6b26b'];
  const playersCount = keymaps.length;
  const playerShapes = [];
  const stopPlayerFns = [];
  const requestReRender = () => {
    renderer(playerShapes);
  };
  const createNewShape = (i) => {
    const index = Math.floor(Math.random() * SHAPE_TYPES.length);
    const shape = { x: 0, y: 0, type: SHAPE_TYPES[index], color: '#111' };
    shape.x = Math.floor((options.worldWidth / playersCount / 2) * (i * 2 + 1));
    shape.color = PLAYER_COLORS[i % PLAYER_COLORS];
    playerShapes[i].unshift(shape);
    requestReRender();
  };
  const canPerformAction = (i, action) => {
    // TODO: implement checks
    return true;
  };
  const playerActionListener = (i, action) => {
    if (!canPerformAction(i, action)) {
      return;
    }
    const shape = playerShapes[i][0];
    action(shape);
    requestReRender();
  };
  for (let i = 0; i < playersCount; ++i) {
    playerShapes[i] = [];
    createNewShape(i);
  }
  for (let i = 0; i < playersCount; ++i) {
    const keymap = keymaps[i];
    const listener = (action) => playerActionListener(i, action);
    stopPlayerFns[i] = startPlayer(keymap, listener);
  }

  return () => {
    stopPlayerFns.forEach((fn) => fn());
  };
};
```

Let's see how it works with a test renderer.

```js
const renderer = (shapes) => {
  console.log('render:');
  console.log(JSON.stringify(shapes[0]));
  console.log(JSON.stringify(shapes[1]));
};
const options = {
  worldWidth: 32,
};
startWorld(keymaps, renderer);
```

Seems to be working fine :)

Let's go ahead and create a simple canvas renderer so we can see what's going on.

```js
const createRenderer = (canvas, options) => {
  const canvasWidth = options.worldWidth * options.worldScale;
  const canvasHeight = options.worldHeight * options.worldScale;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  const ctx = canvas.getContext('2d');

  const renderBlock = (x, y, color) => {
    ctx.fillStyle = color;
    ctx.strokeStyle = '#000';
    ctx.fillRect(
      x * options.worldScale,
      y * options.worldScale,
      options.worldScale,
      options.worldScale
    );
    ctx.strokeRect(
      x * options.worldScale,
      y * options.worldScale,
      options.worldScale,
      options.worldScale
    );
  };

  const renderShape = (shape) => {
    ctx.save();
    ctx.translate(shape.x * options.worldScale, shape.y * options.worldScale);
    for (let i = 0; i < shape.type.length; ++i) {
      const row = shape.type[i];
      for (let j = 0; j < row.length; ++j) {
        if (row[j]) {
          renderBlock(j, i, shape.color);
        }
      }
    }
    ctx.restore();
  };

  return (playerShapes) => {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    for (let i = 0; i < playerShapes.length; ++i) {
      const shapes = playerShapes[i];
      for (let j = 0; j < shapes.length; ++j) {
        renderShape(shapes[j]);
      }
    }
  };
};
```

The end result looks something like this. Try pressing the "A", "D" keys on the keyboard while the iframe is in focus. It should move the shape left or right.

<iframe
  src="2020-12-13-multiplayer-tetris-game/frames/version-1"
  width="100%"
  height="600"
  frameBorder="none"
  scrolling="no"
/>

The next step is to make things move downwards. We can do that by moving the players active shape 1 unit downwards each second.

```js
const startWorld = (keymaps, renderer, options) => {
  // ...
  const stopGameClock = ticker(() => {
    for (let i = 0; i < playerShapes.length; ++i) {
      playerActionListener(i, ACTION_TYPES.moveDown)
    }
  });
  // ...

  return () => {
    stopGameClock();
    // ...
  };
};
```

The next step is to add some rules to the game world. We can check against these rules before performing any actions. In some cases, rules may trigger the game to emit a new shape. Let's define what the rules can do.

```js
const RULE_ACTIONS = {
  BLOCK_ACTION: 1,
  CREATE_SHAPE: 2,
  END_THE_GAME: 3,
};
```

And then change the player action listener to check the rules.

```js
const startWorld = (keymaps, renderer, ticker, ruleset, options) => {
  // ...
  const playerActionListener = (i, action) => {
    const activeShape = playerShapes[i][0];
    const simulated = Object.create(activeShape);
    action(simulated);
    for (let j = 0; j < ruleset.length; ++j) {
      const ruleFn = ruleset[j];
      const result = ruleFn(simulated, activeShape, playerShapes);
      if (result === RULE_ACTIONS.BLOCK_ACTION) {
        return;
      } else if (result === RULE_ACTIONS.CREATE_SHAPE) {
        createNewShape(i);
        return;
      } else if (result === RULE_ACTIONS.END_THE_GAME) {
        alert('GAME OVER!');
        stopWorld();
      }
    }
    action(activeShape);
    requestReRender();
  };
  const stopGameClock = ticker(() => {
    for (let i = 0; i < playerShapes.length; ++i) {
      playerActionListener(i, ACTION_TYPES.moveDown);
    }
  });
  const stopWorld = () => {
    stopGameClock();
    stopPlayerFns.forEach((fn) => fn());
  };
  // ...
  return stopWorld;
};
```

And add some rules to the game world.

```js
const createGameRules = (options) => {
  const doesBBoxOverlap = (s1, s2) => {
    if (
      s1.x > s2.x + s2.type[0].length ||
      s1.x + s1.type[0].length < s2.x ||
      s1.y > s2.y + s2.type.length ||
      s1.y + s1.type.length < s2.y
    ) {
      return false;
    }
    return true;
  };
  const doesBlockOverlap = (s1, row, col, s2) => {
    if (!s1.type[row][col]) {
      return false;
    }
    const s2row = row + s1.y - s2.y;
    const s2col = col + s1.x - s2.x;
    if (s2.type[s2row] && s2.type[s2row][s2col]) {
      return true;
    }
    return false;
  };
  const getOtherShapes = function* (activeShape, playerShapes) {
    for (let i = 0; i < playerShapes.length; ++i) {
      const shapes = playerShapes[i];
      for (let j = 0; j < shapes.length; ++j) {
        const shape = shapes[j];
        if (shape === activeShape) {
          continue;
        }
        yield [shape, j === 0];
      }
    }
  };
  const isBlockedFromLeft = (simulated, activeShape, playerShapes) => {
    if (simulated.type === activeShape.type && simulated.x >= activeShape.x) {
      return null;
    }
    if (simulated.x < 0) {
      return RULE_ACTIONS.BLOCK_ACTION;
    }
    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const col = 0;
      for (let row = 0; row < simulated.type.length; ++row) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          return RULE_ACTIONS.BLOCK_ACTION;
        }
      }
    }
    return null;
  };
  const isBlockedFromRight = (simulated, activeShape, playerShapes) => {
    if (simulated.type === activeShape.type && simulated.x <= activeShape.x) {
      return null;
    }
    if (simulated.x + simulated.type[0].length > options.worldWidth) {
      return RULE_ACTIONS.BLOCK_ACTION;
    }
    for (let [shape] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const col = simulated.type[0].length - 1;
      for (let row = 0; row < simulated.type.length; ++row) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          return RULE_ACTIONS.BLOCK_ACTION;
        }
      }
    }
    return null;
  };
  const isBlockedFromBottom = (simulated, activeShape, playerShapes) => {
    if (simulated.type === activeShape.type && simulated.y <= activeShape.y) {
      return null;
    }
    if (simulated.y + simulated.type.length > options.worldHeight) {
      return RULE_ACTIONS.CREATE_SHAPE;
    }
    for (let [shape, isActive] of getOtherShapes(activeShape, playerShapes)) {
      if (!doesBBoxOverlap(simulated, shape)) {
        continue;
      }
      const row = simulated.type.length - 1;
      for (let col = 0; col < simulated.type[0].length; ++col) {
        if (doesBlockOverlap(simulated, row, col, shape)) {
          if (simulated.y <= 0) {
            return RULE_ACTIONS.END_THE_GAME;
          }
          if (isActive) {
            return RULE_ACTIONS.BLOCK_ACTION;
          }
          return RULE_ACTIONS.CREATE_SHAPE;
        }
      }
    }
    return null;
  };
  return [isBlockedFromLeft, isBlockedFromRight, isBlockedFromBottom];
};
```

The result looks like this. Please click on the button to start the game.

<iframe
  src="2020-12-13-multiplayer-tetris-game/frames/version-2"
  width="100%"
  height="600"
  frameBorder="none"
  scrolling="no"
/>

We can stop it here for the MVP. There's a lot of work left to do which we'll cover in future blog posts.
