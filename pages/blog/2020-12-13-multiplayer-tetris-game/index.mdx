import { createPostContent } from 'theme/PostContent';
import imgTetrisGame from './images/tetris-game.png';
import imgBasicComponents from './images/basic-components.png';

export const meta = {
  title: 'Multiplayer Tetris Game',
  info:
    'A tutorial about writing a multiplayer game from scratch. Starting from solidifying the requirements and continues all the way up to creating a working prototype.',
  date: '2020-12-13',
  tags: ['js'],
};

export default createPostContent({ meta });

# Multiplayer Tetris Game

I just wanted to see what it would look like if multiple players try to play Tetris on the same canvas. Let's build this game in multiple rounds where the result of each iteration is a playable game.

<img src={imgTetrisGame} width="1000" height="700" alt="Tetris game concept" />

These are our requirements for version 1:

- it should be possible for multiple players to play the game
- it should support all the basic rules of a "Tetris" like game

This is what we're NOT doing for version 1:

- avoid support for playing with multiple devices, create a split-screen multiplayer game
- avoid support for mobile devices, touch controls, etc.

## Basic Components

Before building, let's list down all the basic components. If we get this good enough, it may survive this version and some future versions of this game.

<img
  src={imgBasicComponents}
  width="1000"
  height="400"
  alt="Basic components of the game"
/>

And we also need to define some rules to determine how it should behave. We may change these later but having some at the beginning makes it easy to develop.

- All shapes in the game world must be visible on the screen.
- Shapes must not overlap with other shapes in the game world.
- When the game clock ticks, active shapes will move downwards. If they cannot move downwards they will become inactive.
- Players can move their active shapes left, right or rotate them using actions but only if there is enough empty space.

I guess that's enough to get us started. Let's convert what we have designed so far to code to see if it all makes any sense.

## Writing the code

Let's start with a list of shape types. We can represent each shape type as a 2D array. The '1's represent filled blocks and the '0's will represent holes.

```js
const SHAPE_TYPES = [
  [
    [1, 1],
    [1, 1],
  ],
];
```

On the other end, we have the player. The most important thing we need from a player is to listen to actions from the player. So what are these actions? let's define actions as simple functions which manipulate the active shape. For example, the moveLeft and moveRight functions will modify the 'x' position of the shape.

```js
const ACTION_TYPES = {
  moveLeft: (shape) => {
    shape.x--;
  },

  moveRight: (shape) => {
    shape.x++;
  },
};
```

The player holds a listener function and calls it when the user performs certain actions. We will require a listener function and a map of keycode to action functions.

```js
const startPlayer = (keymap, listener) => {
  document.addEventListener('keydown', (e) => {
    for (const key of Object.keys(keymap)) {
      if (e.code === key) {
        listener(keymap[key]);
        break;
      }
    }
  });
};
```

We don't even have a game to play with but we already have some technical debt :D. Let's clean it up just to keep things clean.

```js
// the returned function must be called to destroy the player
const startPlayer = (keymap, listener) => {
  const keyDownListener = (e) => {
    for (const key of Object.keys(keymap)) {
      if (e.code === key) {
        listener(keymap[key]);
        break;
      }
    }
  };
  document.addEventListener('keydown', keyDownListener);

  return () => {
    document.removeEventListener('keydown', keyDownListener);
  };
};
```

And next, the game world. It will bring all the players and the shapes together and renders the output using the given renderer.

```js
const startWorld = (keymaps, renderer) => {
  const playerActionListener = (i, action) => {
    // TODO: apply action on the active shape
  };
  const stopPlayerFunctions = [];
  for (let i = 0; i < keymaps.length; ++i) {
    const keymap = keymaps[i];
    const listener = (action) => playerActionListener(i, action);
    stopPlayerFunctions[i] = startPlayer(keymap, listener);
  }

  return () => {
    stopPlayerFunctions.forEach((fn) => fn());
  };
};
```
